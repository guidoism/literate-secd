** Main CWEB File

#+begin_src cweb :noweb yes :tangle secd.w
@f index int
@f cell int
@f int64_t int
@f uint32_t int
@f uint64_t int

<<Switch to ML Modern Font>>
<<TeX Macros>>
      
\input luamplib.sty
\tenrm

@* Introduction. The SECD abstract machine was originally described by
Peter J. Landin in \paper{The Mechanical Evaluation of Expressions} in 1964.
This particular implementation is based off of Peter Henderson's 1980
book \book{Functional Programming: Application and Implementation} with
additional inspriation from Peter Kogge's 1991 book
\book{The Architecture of Symbolic Computers}.

The motivation for this paper is pedagogical. The audience is the
professional programmer who prefers working code and diagrams over
long prose and unfamiliar mathematical symbols. We also arrange the
program in a narrative order rather than what is preferable to the
compiler. The subject was chosen because this is a well-studied
problem in computer science but isn't particularly well-understood
by the average programmer.

This abstract machine's name is an initialism of the four main
registers: \Stack, \Environment, \Control, and \Dump. The \Stack\
register points to a parameter (or working) stack very similar to
Forth's. The \Environment\ register points to a stack of variable
frames -- for lack of a better name -- where each frame contains a
list of the values that the variables contained at the time of the
frame's creation. The \Control\ register points to a list
of instructions. The \Dump\ register points to yet another stack, this
time for saving the values of the \Stack, \Environment, and \Control\
registers while they are being used with different values inside of
a function call.

@d index uint32_t

@<S.E.C.D. Registers@>=
typedef struct { uint64_t val; } cell;
index s, e, c, d;

@ Cells. The memory in this machine is divided up into 64-bit tagged
cells. Each cell can contain either: a \emph{cons} of two pointers
(the \emph{car} and \emph{cdr}), a number, a character, or a symbol.
A symbol is like a cons cell but the first part is a character and the
second is a pointer to the next cell. We need 2 bits for the tag
which we place on the rightmost end of the word.

\medskip
\mplibcode
    beginfig(4);
        <<Cell Structure Figure>>
    endfig;
\endmplibcode
\medskip

For each cell type we will define macros to 1. Create a cell from parts,
2. Test whether the cell is of a particular type, and 3. Extract each
of the parts. From Kogge: Predicates, Selectors, Creators.
Each of these macros operate on a machine's 64-bit registers
--- they don't affect what is stored in the abstract machine's memory.
They each follow a similar pattern: mask\rightarrow shift\rightarrow tag.    
           
@ Numbers. We use 62-bit signed integers. Overflow behavior is undefined
  for now.

GUIDO: The macro |number| was temporarily moved to Allocate Cells and converted to a function.
   
@d mknumber(n)  (cell){(((uint64_t)n) << 2)}
@d isnumber(c)  ((c.val & 0b11) == 0b00)

@ Conses. We store two 31-bit indicies.
   
@d mkcons(h, t) (cell){(((uint64_t)h << 33) | (((uint64_t)t & 0x7fffffff) << 2) | 0b01)}
@d iscons(c)    ((c.val & 0b11) == 0b01)
@d head(c)      (c.val >> 33)
@d tail(c)      ((c.val >> 2) & 0x7fffffff)

@ Symbols. These are lists of characters where the head is character and
  the tail is a pointer to the next character. We have 31 bits available
  for the character and nothing prevents us from stuffing in more than one
  character. We could for examplee store up to four 7-bit ASCII characters.
   
@d mksymbol(h, t) (cell){((((uint64_t)h) << 33) | (((uint64_t)t & 0x7fffffff) << 2) | 0b11)}
@d issymbol(c)    ((c.val & 0b11) == 0b11)

@ Cell Initialization. During initialization we turn all unused memory
into one long linked list of cons cells. We keep track of the head of
this list with the |f| register.

<<Free List Figure>>

Note that these are indicies, not pointers. They increase by
one, not by 8, so we gain an extra 3 bits of address space.

@d NIL 0
@d T 999
@d F 998
   
@<Cell Initialization@>=

<<Cell Initialization>>       

@ Allocate Cells. We arbitrarily set the size of memory to 65536 cells but
  we have 31 bits available so we could just as easily increase |limit| to
  $2^{31}$.

@d limit 65536
       
@<Allocate Cells@>=

<<Allocate Cells>>
         
@ Instructions. There are 21 instructions as sumerized by this table.
We will go through each one describing the operational semantics
abstractly and provide examples that we will also use to validate
the correctness of this program. Alongside this we will provide the
implementation for each instruction.

\halign{#\hfil\quad&#\hfil\quad&#\hfil\cr
Opcode & Name & Action\cr
\noalign{\smallskip\hrule}\cr
 1 & LD   & Load variable from the environment \cr
 2 & LDC  & Load constant \cr
 3 & LDF  & Load function \cr
 4 & AP   & Apply function \cr
 5 & RTN  & Return \cr
 6 & DUM  & Create dummy environment \cr
 7 & RAP  & Recursive apply \cr
 8 & SEL  & Select subcontrol \cr
 9 & JOIN & Rejoin main control \cr
10 & CAR  & Take |car| of item on top of stack \cr
11 & CDR  & Take |cdr| of item on top of stack \cr
12 & ATOM & Apply |atom| predicate to top stack item \cr
13 & CONS & Form |cons| of top two stack items \cr
14 & EQ   & Apply |eq| predicate to top two stack items \cr
15 & ADD  & Apply arithmetic operation to top two stack items \cr
16 & SUB  & Apply arithmetic operation to top two stack items \cr
17 & MUL  & Apply arithmetic operation to top two stack items \cr
18 & DIV  & Apply arithmetic operation to top two stack items \cr
19 & REM  & Apply arithmetic operation to top two stack items \cr
20 & LEQ  & Apply arithmetic operation to top two stack items \cr
21 & STOP & Stop \cr
}

@ LD Instruction. This is how we access values in the environment. The
LD instruction takes a pair of indicies |(x.y)|. The first index is
what is best described as the frame. An |x| of 0 is the most recent
frame of values, an |x| of 1 is the next most recent, and so on. The
second index is the location of the value within the frame. Each named
variable gets a location within the frame and each lexical scope gets
a frame.

Operational semantics: $s$ $e$ (LD $i.c$) $d$ \enspace\to\enspace ($x.s$) $e$ $c$ $d$ where $x$ = locate($i$, $e$)

\medskip\medskip
\mplibcode
beginfig(1);
<<metapost-graph-init>>
<<make_figure(mem=ld-memory, positions=ld-before)>>        
endfig;
\endmplibcode
\medskip\medskip
            
@<LD Instruction@>=

<<LD Instruction>>

@ LDC Instruction. Loads the constant which is expected to appear as
the next item in the control.

Operational semantics: $s$ $e$ (LDC $x.c$) $d$ \enspace\to\enspace ($x.s$) $e$ $c$ $d$

@<LDC Instruction@>=

<<LDC Instruction>>

@ LDF Instruction. Loads a closure consisting of a function and an
environment onto the stack. Operational semantics: $s$ $e$ (LDF $c'.c$)
$d$ \enspace\to\enspace (($c'.e$)$.s$) $e$ $c$ $d$

\medskip
\medskip
\medskip
\medskip

\halign{#\hfil\quad&#\hfil\quad&#\hfil\quad&#\hfil\cr
Stack & Environment & Control & Dump\cr
\noalign{\smallskip\hrule}\cr
(0)                              & ((3 7) (A)) & (LDF (LD (1.1) RTN) LD (0.1)) & NIL \cr
(((LD (1.1) RTN).((3 7) (A))) 0) & ((3 7) (A)) & (LD (0.1))                    & NIL \cr
}

\medskip\medskip
\mplibcode
beginfig(3);
<<metapost-graph-init>>
<<make_figure(mem=ldf-memory, positions=ldf-before)>>
picture pic;
pic := currentpicture;
currentpicture := nullpicture;
draw pic shifted ((-dx*8),0);
<<make_figure(mem=ldf-memory, positions=ldf-after)>>
pair a,b,c;
a := (point 1 of cell[101] + (-.25w,-.5h));
b := (5*dx+.15w,dy-h-.15h);
c := (point 0 of cell[3] + (.25w,0));
drawarrow a{right}..b..c;
endfig;
\endmplibcode
\medskip\medskip

@<LDF Instruction@>=
<<LDF Instruction>>

@ AP Instruction. ``Applies'' the loaded function: 1. Save the
existing state in the dump and 2. Replaces the control and environment
with the new closure. The function isn't run, but the state is set
up so that when the SECD machine looks for the next instruction it
gets it from this newly installed control for this applied function.
Operational semantics: $((c'.e')\ v.s)$ $e$ $({\rm AP}.c)$ $d$ \enspace\to\enspace NIL $(v.e')$ $c'$ $(s\ e\ c.d)$

<<make_tex_secd_table(ap-before-after-sexp)>>

\medskip\medskip
\mplibcode
beginfig(4);
<<metapost-graph-init>>
<<make_figure(mem=ap-memory, positions=ap-before)>>
picture pic;
pic := currentpicture;
currentpicture := nullpicture;
draw pic shifted (0,(-dy*8));
<<make_figure(mem=ap-memory, positions=ap-after)>>
endfig;
\endmplibcode
\medskip\medskip

@<AP Instruction@>=
<<AP Instruction>>

@ RTN Instruction. Complements the AP instruction by restoring the state
  from the dump. Operational semantics: $(x)\ e'\ (RTN)\ (s\ e\ c.d) \enspace\to\enspace (x.s)\ e\ c\ d$

<<make_tex_secd_table(rtn-before-after-sexp)>>

\medskip\medskip
\mplibcode
beginfig(4);
<<metapost-graph-init>>
<<make_figure(mem=rtn-memory, positions=rtn-before)>>
picture pic;
pic := currentpicture;
currentpicture := nullpicture;
draw pic shifted (0,(-dy*8));
<<make_figure(mem=rtn-memory, positions=rtn-after)>>
endfig;
\endmplibcode
\medskip\medskip
            
@<RTN Instruction@>=
<<RTN Instruction>>
      
@ DUM Instruction. Creates a ``dummy'' environment with \Omega\ as its first sublist. \Omega\ 
  exists to xxx.
  
  Operational semantics: $ s\ e\ (DUM.c)\ d \enspace\to\enspace s\ (\Omega\.e)\ c\ d$
  
@<DUM Instruction@>=
<<DUM Instruction>>

@ RAP Instruction.
  
  Operational semantics: $((c'.e')\ v.s)\ (\Omega.e)\ (RAP.c)\ d \enspace\to\enspace NIL\ rplaca(e', v)\ c' (s\ e\ c.d)$
  
@<RAP Instruction@>=
<<RAP Instruction>>

@ SEL Instruction.
  Operational semantics: $ (x.s)\ e\ (SEL\ c_t\ c_f.c)\ d \enspace\to\enspace s\ e\ c_x\ (c.d)$

\medskip\medskip
\mplibcode
beginfig(4);
<<metapost-graph-init>>
<<make_figure(mem=sel-memory, positions=sel-before)>>
picture pic;
pic := currentpicture;
currentpicture := nullpicture;
draw pic shifted ((-dx*8),0);
<<make_figure(mem=sel-memory, positions=sel-after)>>
endfig;
\endmplibcode
\medskip\medskip
            
@<SEL Instruction@>=
<<SEL Instruction>>
      
@ JOIN Instruction.
  Operational semantics: $ s\ e\ (JOIN)\ (c.d) \enspace\to\enspace s\ e\ c\ d$
@<JOIN Instruction@>=
<<JOIN Instruction>>
       
@ CAR Instruction.
  Operational semantics: $ ((a.b).s)\ e\ (CAR.c)\ d \enspace\to\enspace (a.s)\ e\ c\ d$

\medskip\medskip
\mplibcode
beginfig(4);
<<metapost-graph-init>>
<<make_figure(mem=car-memory, positions=car-before)>>
picture pic;
pic := currentpicture;
currentpicture := nullpicture;
draw pic shifted ((-dx*8),0);
<<make_figure(mem=car-memory, positions=car-after)>>
endfig;
\endmplibcode
\medskip\medskip
  
@<CAR Instruction@>=
<<CAR Instruction>>
      
@ CDR Instruction.
  Operational semantics: $ ((a.b).s)\ e\ (CDR.c)\ d \enspace\to\enspace (b.s)\ e\ c\ d$

\medskip\medskip
\mplibcode
beginfig(4);
<<metapost-graph-init>>
<<make_figure(mem=cdr-memory, positions=cdr-before)>>
picture pic;
pic := currentpicture;
currentpicture := nullpicture;
draw pic shifted ((-dx*8),0);
<<make_figure(mem=cdr-memory, positions=cdr-after)>>
endfig;
\endmplibcode
\medskip\medskip

@<CDR Instruction@>=
<<CDR Instruction>>
      
@ ATOM Instruction.
  Operational semantics: $ (a.s)\ e\ (ATOM.c)\ d \enspace\to\enspace (t.s)\ e\ c\ d$ where $t$
  is true if $a$ is an atom.

\medskip\medskip
\mplibcode
beginfig(4);
<<metapost-graph-init>>
<<make_figure(mem=atom-memory, positions=atom-before)>>
picture pic;
pic := currentpicture;
currentpicture := nullpicture;
draw pic shifted ((-dx*8),0);
<<make_figure(mem=atom-memory, positions=atom-after)>>
endfig;
\endmplibcode
\medskip\medskip

@<ATOM Instruction@>=
<<ATOM Instruction>>
       
@ CONS Instruction.
  Operational semantics: $ (a\ b.s)\ e\ (CONS.c)\ d \enspace\to\enspace ((a.b).s)\ e\ c\ d$
  
\medskip\medskip
\mplibcode
beginfig(4);
<<metapost-graph-init>>
<<make_figure(mem=cons-memory, positions=cons-before)>>
picture pic;
pic := currentpicture;
currentpicture := nullpicture;
draw pic shifted ((-dx*8),0);
<<make_figure(mem=cons-memory, positions=cons-after)>>
endfig;
\endmplibcode
\medskip\medskip

@<CONS Instruction@>=
<<CONS Instruction>>
       
@ EQ Instruction.
  Operational semantics: $ (a\ b.s)\ e\ (EQ.c)\ d \enspace\to\enspace (x.s)\ e\ c\ d$
  where $x$ is true if $a = b$.

\medskip\medskip
\mplibcode
beginfig(4);
<<metapost-graph-init>>
<<make_figure(mem=eq-memory, positions=eq-before)>>
picture pic;
pic := currentpicture;
currentpicture := nullpicture;
draw pic shifted ((-dx*8),0);
<<make_figure(mem=eq-memory, positions=eq-after)>>
endfig;
\endmplibcode
\medskip\medskip
  
@<EQ Instruction@>=
<<EQ Instruction>>
     
@ ADD Instruction.
  Operational semantics: $ (a\ b.s)\ e\ (ADD.c)\ d \enspace\to\enspace (b+a.s)\ e\ c\ d$

\medskip\medskip
\mplibcode
beginfig(4);
<<metapost-graph-init>>
<<make_figure(mem=add-memory, positions=add-before)>>
picture pic;
pic := currentpicture;
currentpicture := nullpicture;
draw pic shifted ((-dx*8),0);
<<make_figure(mem=add-memory, positions=add-after)>>
endfig;
\endmplibcode
\medskip\medskip
  
@<ADD Instruction@>=
<<ADD Instruction>>
      
@ SUB Instruction.
  Operational semantics: $ (a\ b.s)\ e\ (SUB.c)\ d \enspace\to\enspace (b-a.s)\ e\ c\ d$

\medskip\medskip
\mplibcode
beginfig(4);
<<metapost-graph-init>>
<<make_figure(mem=sub-memory, positions=sub-before)>>
picture pic;
pic := currentpicture;
currentpicture := nullpicture;
draw pic shifted ((-dx*8),0);
<<make_figure(mem=sub-memory, positions=sub-after)>>
endfig;
\endmplibcode
\medskip\medskip
  
@<SUB Instruction@>=
<<SUB Instruction>>
      
@ MUL Instruction.
  Operational semantics: $ (a\ b.s)\ e\ (MUL.c)\ d \enspace\to\enspace (b\times a.s)\ e\ c\ d$

\medskip\medskip
\mplibcode
beginfig(4);
<<metapost-graph-init>>
<<make_figure(mem=mul-memory, positions=mul-before)>>
picture pic;
pic := currentpicture;
currentpicture := nullpicture;
draw pic shifted ((-dx*8),0);
<<make_figure(mem=mul-memory, positions=mul-after)>>
endfig;
\endmplibcode
\medskip\medskip
  
@<MUL Instruction@>=
<<MUL Instruction>>
      
@ DIV Instruction.
  Operational semantics: $ (a\ b.s)\ e\ (DIV.c)\ d \enspace\to\enspace (b\div a.s)\ e\ c\ d$

\medskip\medskip
\mplibcode
beginfig(4);
<<metapost-graph-init>>
<<make_figure(mem=div-memory, positions=div-before)>>
picture pic;
pic := currentpicture;
currentpicture := nullpicture;
draw pic shifted ((-dx*8),0);
<<make_figure(mem=div-memory, positions=div-after)>>
endfig;
\endmplibcode
\medskip\medskip
  
@<DIV Instruction@>=
<<DIV Instruction>>
      
@ REM Instruction.
  Operational semantics: $ (a\ b.s)\ e\ (REM.c)\ d \enspace\to\enspace (b\ mod\ a.s)\ e\ c\ d$

\medskip\medskip
\mplibcode
beginfig(4);
<<metapost-graph-init>>
<<make_figure(mem=rem-memory, positions=rem-before)>>
picture pic;
pic := currentpicture;
currentpicture := nullpicture;
draw pic shifted ((-dx*8),0);
<<make_figure(mem=rem-memory, positions=rem-after)>>
endfig;
\endmplibcode
\medskip\medskip
  
@<REM Instruction@>=
<<REM Instruction>>
      
@ LEQ Instruction.
  Operational semantics: $ (a\ b.s)\ e\ (LEQ.c)\ d \enspace\to\enspace (b \leq a.s)\ e\ c\ d$

\medskip\medskip
\mplibcode
beginfig(4);
<<metapost-graph-init>>
<<make_figure(mem=leq-memory, positions=leq-before)>>
picture pic;
pic := currentpicture;
currentpicture := nullpicture;
draw pic shifted ((-dx*8),0);
<<make_figure(mem=leq-memory, positions=leq-after)>>
endfig;
\endmplibcode
\medskip\medskip
  
@<LEQ Instruction@>=
<<LEQ Instruction>>
      
@ STOP Instruction.
  Operational semantics: $ s\ e\ (STOP.c)\ d \enspace\to\enspace s\ e\ (STOP.c)\ d$
@<STOP Instruction@>=
<<STOP Instruction>>


@ Discussion.       

Our principles are: 1. We won't blindly follow the DRY principle.
If the code is more clear being repeated then we will repeat it.
Sometimes the pattern is better seen by seeing the repetition and
differences. The |pop| functions could have been written with the
following macro but we determined that it obscured understanding.
       
@ Futher Research.

  The code to build this paper is a mess. It's a mixture of Python, C,
  Metapost, CWEB, noweb, and Org Mode.

  Use of characters not allowed in C identifiers would be helpful, for
  example using a question mark in functions that return a boolean
  would read a bit better.

  Better bit manipulation syntax.

  Invariant syntax.

  MMIXAL code instead of C.

  Forth instead of SECD and compare and contrast the two abstract machines.
             
@* Testing Main.

@c
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <assert.h>
@<S.E.C.D. Registers@>;
@<Allocate Cells@>;
@<LD Instruction@>;
@<LDC Instruction@>;
@<LDF Instruction@>;
@<AP Instruction@>;
@<RTN Instruction@>;
@<DUM Instruction@>;
@<RAP Instruction@>;
@<SEL Instruction@>;
@<JOIN Instruction@>;
@<CAR Instruction@>;
@<CDR Instruction@>;
@<ATOM Instruction@>;
@<CONS Instruction@>;
@<EQ Instruction@>;
@<ADD Instruction@>;
@<SUB Instruction@>;
@<MUL Instruction@>;
@<DIV Instruction@>;
@<REM Instruction@>;
@<LEQ Instruction@>;
@<STOP Instruction@>;
         
@<Print S-Expressions Utility@>;      
@<Validate Implementation@>;

int main(void) @+ {
    @<Cell Initialization@>;
    validate_cell_implementation();
    validate_ld_implementation();
    validate_ldc_implementation();
    validate_ldf_implementation();
    validate_car_implementation();
    validate_atom_implementation();
    validate_cons_implementation();
    validate_eq_implementation();
    validate_add_implementation();
    validate_sub_implementation();
    validate_mul_implementation();
    validate_div_implementation();
    validate_rem_implementation();
    validate_leq_implementation();
    validate_stop_implementation();
}

@ Print S-Expressions Utility.
        
@<Print S-Expressions Utility@>=

void print_sexp(index i) @+ {
    cell c = mem[i];
    if (iscons(c)) @+ {
        if (head(c)) print_sexp(head(c));
        printf(" ");
        if (tail(c)) print_sexp(tail(c));
    }
    else printf(" %lld ", getnumber2(c));

}
        
@* Appendix.

@d deref_number_from_cell(c) ((int64_t)c.val >> 2)

@<Validate Implementation@>=

<<Validate Cell Implementation>>
           
// TODO: Show graphs of cells instead in weave mode
void validate_ld_implementation(void) @+ {
    <<make_tests(mem=ld-memory, positions=ld-before)>>
    e = 36;
    c = 8;
    f = 40;
    index w = popc();
    assert(w == 7);
    assert(getnumber2(mem[w]) == 1); // LD
    assert(c == 12);
    ld();
    assert(head(mem[head(mem[s])]) == 25);
}

void validate_ldc_implementation(void) @+ {
    f = 200;
    c = 100;
    mem[100] = mkcons(101, 102);
    mem[102] = mkcons(103, 0);
    mem[101] = mknumber(2);
    mem[103] = mknumber(42);
    index w = popc();
    assert(getnumber2(mem[w]) == 2); // LDC
    ldc();
    assert(getnumber2(mem[head(mem[s])]) == 42);
}

void validate_ldf_implementation(void) @+ {
    <<make_tests(mem=ldf-memory, positions=ldf-before)>>
    s = 1;
    e = 3;
    c = 12;
    f = 100;
    index w = popc();
    assert(getnumber2(mem[w]) == 3); // LDF
    ldf();
    assert(head(mem[head(mem[s])]) == 20);
}

void validate_car_implementation(void) @+ {
}        

void validate_atom_implementation(void) @+ {
    <<make_tests(mem=atom-memory, positions=atom-before)>>
    s = 3;
    e = 0;
    c = 1;
    f = 9;
    index w = popc();
    assert(getnumber2(mem[w]) == 12); // ATOM
    atom();
    assert(head(mem[s]) == F);
    atom();
    assert(head(mem[s]) == T);
}

void validate_cons_implementation(void) @+ {
    <<make_tests(mem=cons-memory, positions=cons-before)>>
    s = 3;
    e = 0;
    c = 1;
    f = 10;
    index w = popc();
    assert(getnumber2(mem[w]) == 13); // CONS
    cons();
    assert(head(mem[s]) == 10);
    assert(head(mem[head(mem[s])]) == 6);
    assert(tail(mem[head(mem[s])]) == 7);
}

void validate_eq_implementation(void) @+ {
    <<make_tests(mem=eq-memory, positions=eq-before)>>
    s = 3;
    e = 0;
    c = 21;
    f = 10;
    index w = popc();
    assert(getnumber2(mem[w]) == 14); // EQ
    eq();
    assert(head(mem[s]) == T);
    eq();
    assert(head(mem[s]) == F);
}

void validate_add_implementation() @+ {
    <<make_tests(mem=add-memory, positions=add-before)>>
    s = 3;
    e = 0;
    c = 21;
    f = 10;
    index w = popc();
    assert(getnumber2(mem[w]) == 15); // ADD
    add();
    assert(getnumber2(mem[head(mem[s])]) == 12);
}
        
void validate_sub_implementation() @+ {
    <<make_tests(mem=sub-memory, positions=sub-before)>>
    s = 3;
    e = 0;
    c = 21;
    f = 10;
    index w = popc();
    assert(getnumber2(mem[w]) == 16); // SUB
    sub();
    assert(getnumber2(mem[head(mem[s])]) == 2);
}
        
void validate_mul_implementation() @+ {
    <<make_tests(mem=mul-memory, positions=mul-before)>>
    s = 3;
    e = 0;
    c = 21;
    f = 10;
    index w = popc();
    assert(getnumber2(mem[w]) == 17); // MUL
    mul();
    assert(getnumber2(mem[head(mem[s])]) == 35);
}
        
void validate_div_implementation() @+ {
    <<make_tests(mem=div-memory, positions=div-before)>>
    s = 3;
    e = 0;
    c = 21;
    f = 10;
    index w = popc();
    assert(getnumber2(mem[w]) == 18); // DIV
    div();
    assert(getnumber2(mem[head(mem[s])]) == 1);
}
        
void validate_rem_implementation() @+ {
    <<make_tests(mem=rem-memory, positions=rem-before)>>
    s = 3;
    e = 0;
    c = 21;
    f = 10;
    index w = popc();
    assert(getnumber2(mem[w]) == 19); // REM
    rem();
    assert(getnumber2(mem[head(mem[s])]) == 2);
}
        
void validate_leq_implementation() @+ {
    <<make_tests(mem=leq-memory, positions=leq-before)>>
    s = 3;
    e = 0;
    c = 21;
    f = 10;
    index w = popc();
    assert(getnumber2(mem[w]) == 20); // LEQ
    leq();
    assert(head(mem[s]) == F);
}
        
void validate_stop_implementation() @+ {
}
        
#+end_src




** Put together everything

#+begin_src elisp 
(org-babel-tangle)
(org-sbe weaveit)
#+end_src

#+RESULTS:
: nil

#+name: weaveit
#+begin_src sh :results output
cweave secd
luatex secd
#+end_src

** Instructions

#+name: Instructions
| Opcode | Name | Action                                            |
|      1 | LD   | Load variable from the environment                |
|      2 | LDC  | Load constant                                     |
|      3 | LDF  | Load function                                     |
|      4 | AP   | Apply function                                    |
|      5 | RTN  | Return                                            |
|      6 | DUM  | Create dummy environment                          |
|      7 | RAP  | Recursive apply                                   |
|      8 | SEL  | Select subcontrol                                 |
|      9 | JOIN | Rejoin main control                               |
|     10 | CAR  | Take car of item on top of stack                  |
|     11 | CDR  | Take cdr of item on top of stack                  |
|     12 | ATOM | Apply atom predicate to top stack item            |
|     13 | CONS | Form cons of top two stack items                  |
|     14 | EQ   | Apply eq predicate to top two stack items         |
|     15 | ADD  | Apply arithmetic operation to top two stack items |
|     16 | SUB  | Apply arithmetic operation to top two stack items |
|     17 | MUL  | Apply arithmetic operation to top two stack items |
|     18 | DIV  | Apply arithmetic operation to top two stack items |
|     19 | REM  | Apply arithmetic operation to top two stack items |
|     20 | LEQ  | Apply arithmetic operation to top two stack items |
|     21 | STOP | Stop                                              |

** Validation Data

#+name: ld-memory
| addr | type | head | tail | val |
|    7 | atom |      |      | LD  |
|    8 | cons |    7 |   12 |     |
|    9 | atom |      |      | 0   |
|   10 | cons |    9 |   11 |     |
|   11 | atom |      |      | 1   |
|   12 | cons |   10 |   14 |     |
|   13 | atom |      |      | RTN |
|   14 | cons |   13 |    0 |     |
|   20 | atom |      |      | B   |
|   21 | cons |   20 |   23 |     |
|   22 | atom |      |      | C   |
|   23 | cons |   22 |    0 |     |
|   24 | cons |   21 |   29 |     |
|   25 | atom |      |      | D   |
|   26 | cons |   25 |   28 |     |
|   27 | atom |      |      | E   |
|   28 | cons |   27 |    0 |     |
|   29 | cons |   26 |    0 |     |
|   36 | cons |   24 |    0 |     |

    e = 36;
    c = 8;
    f = 40;

#+name: ld-before
| E | 36 |    |    |    |
|   | 24 |    | 29 |    |
|   | 21 | 23 | 26 | 28 |
|   | 20 | 22 | 25 | 27 |
| C |  8 | 12 |    | 14 |
|   |  7 | 10 | 11 | 13 |
|   |    |  9 |    |    |


#+name: ld-after
|   |   |
|   |   |

#+name: ldf-memory
| addr | type | head | tail | val |
|    0 | cons |    0 |    0 |     |
|    1 | cons |    2 |    0 |     |
|    2 | atom |      |      |   0 |
|    3 | cons |    6 |    5 |     |
|    5 | cons |    8 |    0 |     |
|    6 | cons |    9 |    7 |     |
|    7 | cons |   10 |    0 |     |
|    8 | cons |   11 |    0 |     |
|    9 | atom |      |      |   3 |
|   10 | atom |      |      |   7 |
|   11 | atom |      |      |   A |
|   12 | cons |   19 |   13 |     |
|   13 | cons |   20 |   16 |     |
|   16 | cons |   23 |   17 |     |
|   17 | cons |   24 |    0 |     |
|   19 | atom |      |      | LDF |
|   20 | cons |   27 |   21 |     |
|   21 | cons |   28 |   22 |     |
|   22 | cons |   29 |    0 |     |
|   23 | atom |      |      |  LD |
|   24 | cons |   31 |    0 |     |
|   27 | atom |      |      |  LD |
|   28 | cons |   35 |   29 |     |
|   29 | atom |      |      | RTN |
|   31 | cons |   38 |   32 |     |
|   32 | atom |      |      |   1 |
|   35 | cons |   42 |   36 |     |
|   36 | atom |      |      |   1 |
|   38 | atom |      |      |   0 |
|   42 | atom |      |      |   1 |
|  100 | cons |  101 |    1 |     |
|  101 | cons |   20 |    3 |     |

#+name: ldf-before
| S |  1 |    |    |    |    |    |    |
|   |  2 |    |    |    |    |    |    |
| E |  3 |    |  5 |    |    |    |    |
|   |  6 |  7 |  8 |    |    |    |    |
|   |  9 | 10 | 11 |    |    |    |    |
| C | 12 | 13 |    |    | 16 | 17 |    |
|   | 19 | 20 | 21 | 22 | 23 | 24 |    |
|   |    | 27 | 28 | 29 |    | 31 | 32 |
|   |    |    | 35 | 36 |    | 38 |    |
|   |    |    | 42 |    |    |    |    |

#+name: ldf-after
| S |  100 |    |    |   |    |  1 |    |
|   | 101* |    |    |   |    |  2 |    |
|   |   20 | 21 | 22 | E |  3 |    |  5 |
|   |   27 | 28 | 29 |   |  6 |  7 |  8 |
|   |      | 35 | 36 |   |  9 | 10 | 11 |
|   |      | 42 |    |   |    |    |    |
|   |      |    |    | C | 16 | 17 |    |
|   |      |    |    |   | 23 | 24 |    |
|   |      |    |    |   |    | 31 | 32 |
|   |      |    |    |   |    | 38 |    |
|   |      |    |    |   |    |    |    |

#+name: ap-before-after-sexp
| (((LD (1.1) LD (0.0) ADD RTN).((3 7) (A))) (6) 0) | ((2 B))         | (AP STOP)                   | d                      |
| NIL                                               | ((6) (3 7) (A)) | (LD (1.1) LD (0.0) ADD RTN) | ((0) ((2 B)) (STOP).d) |

#+name: ap-memory
| addr | type | head | tail |  val |
|    3 | cons |    4 |    5 |      |
|    4 | atom |      |      |   LD |
|    5 | cons |    6 |    7 |      |
|    6 | cons |   15 |   16 |      |
|    7 | cons |    8 |    9 |      |
|    8 | atom |      |      |   LD |
|    9 | cons |   10 |   11 |      |
|   10 | cons |   17 |   18 |      |
|   11 | cons |   12 |   13 |      |
|   12 | atom |      |      |  ADD |
|   13 | cons |   14 |    0 |      |
|   14 | atom |      |      |  RTN |
|   15 | atom |      |      |    1 |
|   16 | atom |      |      |    1 |
|   17 | atom |      |      |    0 |
|   18 | atom |      |      |    0 |
|   20 | cons |   22 |   21 |      |
|   21 | cons |   24 |    0 |      |
|   22 | cons |   25 |   23 |      |
|   23 | cons |   26 |    0 |      |
|   24 | cons |   27 |    0 |      |
|   25 | atom |      |      |    3 |
|   26 | atom |      |      |    7 |
|   27 | atom |      |      |    A |
|   30 | cons |   31 |    0 |      |
|   31 | atom |      |      |    6 |
|   40 | cons |    3 |   41 |      |
|   41 | cons |   20 |   42 |      |
|   42 | cons |   30 |   52 |      |
|   43 | cons |   44 |    0 |      |
|   44 | cons |   46 |   45 |      |
|   45 | cons |   47 |    0 |      |
|   46 | atom |      |      |    2 |
|   47 | atom |      |      |    B |
|   48 | cons |   50 |   49 |      |
|   49 | cons |   51 |    0 |      |
|   50 | atom |      |      |   AP |
|   51 | atom |      |      | STOP |
|   52 | cons |   53 |    0 |      |
|   53 | atom |      |      |    0 |
|   60 | cons |   30 |   20 |      |
|   61 | cons |   52 |   62 |      |
|   62 | cons |   43 |   63 |      |
|   63 | cons |   49 |    0 |      |

#+name: ap-before
| S | 40 | 41 |    |    | 42 | 52 |  E | 43 |    | C | 48 | 49 |
|   |    | 20 |    | 21 | 30 | 53 |    | 44 | 45 |   | 50 | 51 |
|   |    | 22 | 23 | 24 | 31 |    |    | 46 | 47 |   |    |    |
|   |    | 25 | 26 | 27 |    |    |    |    |    |   |    |    |
|   |  3 |  5 |    |  7 |  9 |    | 11 | 13 |    |   |    |    |
|   |  4 |  6 | 16 |  8 | 10 | 18 | 12 | 14 |    |   |    |    |
|   |    | 15 |    |    | 17 |    |    |    |    |   |    |    |

#+name: ap-after
|   |    |    |    |    |  D | 61 | 62 |    | 63 |
|   |    |    |    |    |    | 52 | 43 |    | 49 |
| E | 60 | 20 |    | 21 |    | 53 | 44 | 45 | 51 |
|   | 30 | 22 | 23 | 24 |    |    | 46 | 47 |    |
|   | 31 | 25 | 26 | 27 |    |    |    |    |    |
| C |  3 |  5 |    |  7 |  9 |    | 11 | 13 |    |
|   |  4 |  6 | 16 |  8 | 10 | 18 | 12 | 14 |    |
|   |    | 15 |    |    | 17 |    |    |    |    |

#+name: rtn-before-after-sexp
| (13)   | ((6) (3 7) (A)) | (RTN)  | ((0) ((2 B)) (STOP).d) |
| (13 0) | ((2 B))         | (STOP) | d                      |

#+name: rtn-memory
| addr | type | head | tail |  val |
|   13 | cons |   14 |    0 |      |
|   14 | atom |      |      |  RTN |
|   20 | cons |   22 |   21 |      |
|   21 | cons |   24 |    0 |      |
|   22 | cons |   25 |   23 |      |
|   23 | cons |   26 |    0 |      |
|   24 | cons |   27 |    0 |      |
|   25 | atom |      |      |    3 |
|   26 | atom |      |      |    7 |
|   27 | atom |      |      |    A |
|   30 | cons |   31 |    0 |      |
|   31 | atom |      |      |    6 |
|   40 | cons |    3 |   41 |      |
|   41 | cons |   20 |   42 |      |
|   42 | cons |   30 |   52 |      |
|   43 | cons |   44 |    0 |      |
|   44 | cons |   46 |   45 |      |
|   45 | cons |   47 |    0 |      |
|   46 | atom |      |      |    2 |
|   47 | atom |      |      |    B |
|   48 | cons |   50 |   49 |      |
|   49 | cons |   51 |    0 |      |
|   50 | atom |      |      |   AP |
|   51 | atom |      |      | STOP |
|   52 | cons |   53 |    0 |      |
|   53 | atom |      |      |    0 |
|   60 | cons |   30 |   20 |      |
|   61 | cons |   52 |   62 |      |
|   62 | cons |   43 |   63 |      |
|   63 | cons |   49 |    0 |      |
|   70 | cons |   71 |    0 |      |
|   71 | atom |      |      |   13 |
|   72 | cons |   71 | 52   |      |

#+name: rtn-before
| S | 70 |    |    |    | D | 61 | 62 |    | 63 |
|   | 71 |    |    |    |   | 52 | 43 |    | 49 |
| E | 60 | 20 |    | 21 |   | 53 | 44 | 45 | 51 |
|   | 30 | 22 | 23 | 24 |   |    | 46 | 47 |    |
|   | 31 | 25 | 26 | 27 |   |    |    |    |    |
| C | 13 |    |    |    |   |    |    |    |    |
|   | 14 |    |    |    |   |    |    |    |    |
|   |    |    |    |    |   |    |    |    |    |

#+name: rtn-after
| S | 72 | 52 | E | 43 |    | C | 49 |
|   | 71 | 53 |   | 44 | 45 |   | 51 |
|   |    |    |   | 46 | 47 |   |    |

#+name: car-memory
| addr | type | head | tail | val |
|    1 | cons |    2 |    0 |     |
|    2 | atom |      |      | CAR |
|    3 | cons |    4 |    5 |     |
|    4 | cons |    7 |    8 |     |
|    5 | cons |    6 |    0 |     |
|    6 | atom |      |      | C   |
|    7 | atom |      |      | A   |
|    8 | atom |      |      | B   |
|    9 | cons |    7 |    5 |     |

#+name: car-before
| S | 3 |   | 5 | C | 1 |
|   | 4 | 8 | 6 |   | 2 |
|   | 7 |   |   |   |   |

#+name: car-after
| S | 9 | 5 | 
|   | 7 | 6 | 

#+name: cdr-memory
| addr | type | head | tail | val |
|    1 | cons |    2 |    0 |     |
|    2 | atom |      |      | CDR |
|    3 | cons |    4 |    5 |     |
|    4 | cons |    7 |    8 |     |
|    5 | cons |    6 |    0 |     |
|    6 | atom |      |      | C   |
|    7 | atom |      |      | A   |
|    8 | atom |      |      | B   |
|    9 | cons |    8 |    5 |     |

#+name: cdr-before
| S | 3 |   | 5 | C | 1 |
|   | 4 | 8 | 6 |   | 2 |
|   | 7 |   |   |   |   |

#+name: cdr-after
| S | 9 | 5 |
|   | 8 | 6 |

#+name: atom-memory
| addr | type   | head | tail | val  |
|    1 | cons   |    2 |    0 |      |
|    2 | atom   |      |      | ATOM |
|    3 | cons   |    4 |    5 |      |
|    4 | cons   |    7 |    8 |      |
|    5 | cons   |    6 |    0 |      |
|    6 | atom   |      |      | C    |
|    7 | atom   |      |      | A    |
|    8 | atom   |      |      | B    |
|    9 | cons   |   10 |    5 |      |
|   10 | symbol |      |    0 | #f   |

#+name: atom-before
| S | 3 |   | 5 | C | 1 |
|   | 4 | 8 | 6 |   | 2 |
|   | 7 |   |   |   |   |

#+name: atom-after
| S |  9 | 5 |
|   | 10 | 6 |

#+name: cons-memory
| addr | type | head | tail | val  |
|    1 | cons |    2 |    0 |      |
|    2 | atom |      |      | CONS |
|    3 | cons |    6 |    4 |      |
|    4 | cons |    7 |    5 |      |
|    5 | cons |    8 |    0 |      |
|    6 | atom |      |      | A    |
|    7 | atom |      |      | B    |
|    8 | atom |      |      | C    |
|   10 | cons |    6 |    7 |      |
|   11 | cons |   10 |    5 |      |

#+name: cons-before
| S | 3 | 4 | 5 | C | 1 |
|   | 6 | 7 | 8 |   | 2 |

#+name: cons-after
| S | 11 |   | 5 |
|   | 10 | 7 | 8 |
|   |  6 |   |   |

#+name: eq-memory
| addr | type | head | tail | val |
|   21 | cons |   22 |   23 |     |
|   22 | atom |      |      | EQ  |
|   23 | cons |   24 |    0 |     |
|   24 | atom |      |      | EQ  |
|    3 | cons |    6 |    4 |     |
|    4 | cons |    7 |    5 |     |
|    5 | cons |    8 |    0 |     |
|    6 | atom |      |      | 2   |
|    7 | atom |      |      | 2   |
|    8 | atom |      |      | 2   |
|   10 | atom |      |      | t   |
|   11 | cons |   10 |    5 |     |

#+name: eq-before
| S | 3 | 4 | 5 | C | 21 | 23 |
|   | 6 | 7 | 8 |   | 22 | 24 |

#+name: eq-after
| S | 11 | 5 | C | 23 |
|   | 10 | 8 |   | 24 |


#+name: add-memory
| addr | type | head | tail | val |
|   21 | cons |   22 |    0 |     |
|   22 | atom |      |      | ADD |
|    3 | cons |    6 |    4 |     |
|    4 | cons |    7 |    0 |     |
|    6 | atom |      |      |   5 |
|    7 | atom |      |      |   7 |
|   10 | atom |      |      |  13 |
|   11 | cons |   10 |    0 |     |

#+name: add-before
| S | 3 | 4 | C | 21 |
|   | 6 | 7 |   | 22 |

#+name: add-after
| S | 11 |   |
|   | 10 |   |

#+name: sub-memory
| addr | type | head | tail | val |
|   21 | cons |   22 |    0 |     |
|   22 | atom |      |      | SUB |
|    3 | cons |    6 |    4 |     |
|    4 | cons |    7 |    0 |     |
|    6 | atom |      |      |   5 |
|    7 | atom |      |      |   7 |
|   10 | atom |      |      |   2 |
|   11 | cons |   10 |    0 |     |

#+name: sub-before
| S | 3 | 4 | C | 21 |
|   | 6 | 7 |   | 22 |

#+name: sub-after
| S | 11 |   |
|   | 10 |   |

#+name: mul-memory
| addr | type | head | tail | val |
|   21 | cons |   22 |    0 |     |
|   22 | atom |      |      | MUL |
|    3 | cons |    6 |    4 |     |
|    4 | cons |    7 |    0 |     |
|    6 | atom |      |      |   5 |
|    7 | atom |      |      |   7 |
|   10 | atom |      |      |  35 |
|   11 | cons |   10 |    0 |     |

#+name: mul-before
| S | 3 | 4 | C | 21 |
|   | 6 | 7 |   | 22 |

#+name: mul-after
| S | 11 |   |
|   | 10 |   |

#+name: div-memory
| addr | type | head | tail | val |
|   21 | cons |   22 |    0 |     |
|   22 | atom |      |      | DIV |
|    3 | cons |    6 |    4 |     |
|    4 | cons |    7 |    0 |     |
|    6 | atom |      |      |   5 |
|    7 | atom |      |      |   7 |
|   10 | atom |      |      |   1 |
|   11 | cons |   10 |    0 |     |

#+name: div-before
| S | 3 | 4 | C | 21 |
|   | 6 | 7 |   | 22 |

#+name: div-after
| S | 11 |   |
|   | 10 |   |

#+name: rem-memory
| addr | type | head | tail | val |
|   21 | cons |   22 |    0 |     |
|   22 | atom |      |      | REM |
|    3 | cons |    6 |    4 |     |
|    4 | cons |    7 |    0 |     |
|    6 | atom |      |      |   5 |
|    7 | atom |      |      |   7 |
|   10 | atom |      |      |   2 |
|   11 | cons |   10 |    0 |     |

#+name: rem-before
| S | 3 | 4 | C | 21 |
|   | 6 | 7 |   | 22 |

#+name: rem-after
| S | 11 |   |
|   | 10 |   |

#+name: leq-memory
| addr | type | head | tail | val |
|   21 | cons |   22 |    0 |     |
|   22 | atom |      |      | LEQ |
|    3 | cons |    6 |    4 |     |
|    4 | cons |    7 |    0 |     |
|    6 | atom |      |      |   5 |
|    7 | atom |      |      |   7 |
|   10 | atom |      |      |   f |
|   11 | cons |   10 |    0 |     |

#+name: leq-before
| S | 3 | 4 | C | 21 |
|   | 6 | 7 |   | 22 |

#+name: leq-after
| S | 11 |   |
|   | 10 |   |

#+name: sel-memory
| addr | type | head | tail | val |
|   21 | cons |   22 |    0 |     |
|   22 | atom |      |      | LEQ |
|    3 | cons |    6 |    4 |     |
|    4 | cons |    7 |    0 |     |
|    6 | atom |      |      |   5 |
|    7 | atom |      |      |   7 |
|   10 | atom |      |      |   f |
|   11 | cons |   10 |    0 |     |

#+name: sel-before
| S | 3 | 4 | C | 21 |
|   | 6 | 7 |   | 22 |

#+name: sel-after
| S | 11 |   |
|   | 10 |   |


** CWEB File

*** TeX Macros

#+name: TeX Macros
#+begin_src tex
\def\paper#1{{\it #1}}
\def\book#1{{\it #1}}
\def\emph#1{{\it #1}}

\def\Stack{{\it Stack}}
\def\Environment{{\it Environment}}
\def\Control{{\it Control}}
\def\Dump{{\it Dump}}
\def\LIFO{{\sc LIFO}}
#+end_src


*** Font Stuff

https://ctan.math.utah.edu/ctan/tex-archive/fonts/mlmodern/doc/mlmodern.pdf
Map files: http://www.readytext.co.uk/?cat=30
https://www.tug.org/texlive/doc/updmap.html
https://tug.org/fonts/fontinstall.html

#+name: Switch to ML Modern Font
#+begin_src tex
%%%%%%%%%%% MLModern font changes
\font\tenrm=rm-mlmr10 % roman text
\font\preloaded=rm-mlmr9
\font\preloaded=rm-mlmr8
\font\sevenrm=rm-mlmr7
\font\preloaded=rm-mlmr6
\font\fiverm=rm-mlmr5
\font\teni=mlmmi10 % math italic
\font\preloaded=mlmmi9
\font\preloaded=mlmmi8
\font\seveni=mlmmi7
\font\preloaded=mlmmi6
\font\fivei=mlmmi5
\font\tensy=mlmsy10 % math symbols
\font\preloaded=mlmsy9
\font\preloaded=mlmsy8
\font\sevensy=mlmsy7
\font\preloaded=mlmsy6
\font\fivesy=mlmsy5
\font\tenex=mlmex10 % math extension
\font\preloaded=rm-mlmss10 % sans serif
\font\preloaded=rm-mlmsso10 % sans serif italic
\font\tenbf=rm-mlmbx10 % boldface extended
\font\preloaded=rm-mlmbx9
\font\preloaded=rm-mlmbx8
\font\sevenbf=rm-mlmbx7
\font\preloaded=rm-mlmbx6
\font\fivebf=rm-mlmbx5
\font\tentt=rm-mlmtt10 % typewriter
\font\preloaded=rm-mlmtt9
\font\preloaded=rm-mlmtt8
\font\preloaded=rm-mlmtto10 % slanted typewriter
\font\tensl=rm-mlmro10 % slanted roman
\font\preloaded=rm-mlmro9
\font\preloaded=rm-mlmro8
\font\tenit=rm-mlmri10 % text italic
\font\preloaded=rm-mlmri9
\font\preloaded=rm-mlmri8
\font\preloaded=rm-mlmri7
\font\preloaded=rm-mlmu10 % unslanted text italic
\font\preloaded=mlmmib10 % bold math italic
\font\preloaded=mlmbsy10 % bold math symbols
\font\preloaded=rm-mlmcsc10 % caps and small caps
\font\preloaded=rm-mlmr7 scaled \magstep4 % for titles
\font\preloaded=rm-mlmtt10 scaled \magstep2
\font\preloaded=rm-mlmssbx10 scaled \magstep2
\let\preloaded=\undefined % preloaded fonts must be declared anew later.
\skewchar\teni='177 \skewchar\seveni='177 \skewchar\fivei='177
\skewchar\tensy='60 \skewchar\sevensy='60 \skewchar\fivesy='60
\textfont0=\tenrm \scriptfont0=\sevenrm \scriptscriptfont0=\fiverm
\textfont1=\teni \scriptfont1=\seveni \scriptscriptfont1=\fivei
\textfont2=\tensy \scriptfont2=\sevensy \scriptscriptfont2=\fivesy
\textfont3=\tenex \scriptfont3=\tenex \scriptscriptfont3=\tenex
\newfam\itfam \def\it{\fam\itfam\tenit} % \it is family 4
\textfont\itfam=\tenit
\newfam\slfam \def\sl{\fam\slfam\tensl} % \sl is family 5
\textfont\slfam=\tensl
\newfam\bffam \def\bf{\fam\bffam\tenbf} % \bf is family 6
\textfont\bffam=\tenbf \scriptfont\bffam=\sevenbf
\scriptscriptfont\bffam=\fivebf
\newfam\ttfam \def\tt{\fam\ttfam\tentt} % \tt is family 7
\textfont\ttfam=\tentt
\font\ninerm=rm-mlmr9 % cmr9
\font\eightrm=rm-mlmr8 % cmr8
\font\sevenrm=rm-mlmr7 % cmr7
\font\titlefont=rm-mlmr7 scaled\magstep4 % title on the contents page
%\font\ttitlefont=cmtt10 scaled\magstep2 % typewriter type in title
%\font\tentex=cmtex10 % TeX extended character set (used in strings)
%%%%%%%%%%% MLModern font changes
#+end_src

*** Allocate Cells

#+name: Allocate Cells
#+begin_src c
cell mem[limit];
index f; // free list

int64_t getnumber2(cell c) @+ {
    return (int64_t)(c.val) >> 2;
}

index addcell(cell c) @+ {
    index w = f;      // Get the next free cell index
    f = tail(mem[f]); // Remove it from the free list
    mem[w] = c;       // Put our newly created cell into our allocated slot
    return w;         // Return the location of our new cell
}

index addcons(index h, index t) @+ {
    return addcell(mkcons(h, t));
}

index pops(void) @+ { 
    index w = head(mem[s]); 
    s = tail(mem[s]); 
    return w; 
}

index popc(void) @+ { 
    index w = head(mem[c]); 
    c = tail(mem[c]); 
    return w; 
}

index popd(void) @+ { 
    index w = head(mem[d]); 
    d = tail(mem[d]); 
    return w; 
}
#+end_src

*** Cell Structure Figure

#+name: Cell Structure Figure
#+begin_src metapost
u = 1mm;
x := 0;
y := 0;
path car, cdr, tag;
car := ((0,0)--(31u,0)--(31u,4u)--(0,4u)--cycle) shifted (0,y);
cdr := ((0,0)--(31u,0)--(31u,4u)--(0,4u)--cycle) shifted (31u,y);
tag := ((0,0)--(6u,0)--(6u,4u)--(0,4u)--cycle) shifted (62u,y);
draw car;
draw cdr;
draw tag;
label.lft("Cons" infont "rm-mlmr9", .5[point 0 of car,point 3 of car]);
label.top("car/head" infont "rm-mlmri9", .5[point 0 of car,point 1 of car] shifted (0,-.5mm));
label.bot("63..34" infont "rm-mlmr9",  .5[point 0 of car,point 1 of car]);
label.top("cdr/tail" infont "rm-mlmri9", .5[point 0 of cdr,point 1 of cdr] shifted (0,-.5mm));
label.bot("33..2" infont "rm-mlmr9",  .5[point 0 of cdr,point 1 of cdr]);
label.top("01" infont "rm-mlmtt8", .5[point 0 of tag,point 1 of tag]);
label.bot("1..0" infont "rm-mlmr9",   .5[point 0 of tag,point 1 of tag]);

x := 0;

y := -10u;
path number;
number := ((0,0)--(62u,0)--(62u,4u)--(0,4u)--cycle) shifted (0,y);
tag := ((0,0)--(6u,0)--(6u,4u)--(0,4u)--cycle) shifted (62u,y);
draw number;
draw tag;
label.lft("Number" infont "rm-mlmr9", .5[point 0 of number,point 3 of number]);
label.top("number" infont "rm-mlmri9", .5[point 0 of number,point 1 of number] shifted (0,.1mm));
label.bot("63..2" infont "rm-mlmr9",  .5[point 0 of number,point 1 of number]);
label.top("00" infont "rm-mlmtt8", .5[point 0 of tag,point 1 of tag]);
label.bot("1..0" infont "rm-mlmr9",   .5[point 0 of tag,point 1 of tag]);

x := 85u;
y := 0;
car := ((0,0)--(31u,0)--(31u,4u)--(0,4u)--cycle) shifted (x,y);
cdr := ((0,0)--(31u,0)--(31u,4u)--(0,4u)--cycle) shifted (x+31u,y);
tag := ((0,0)--(6u,0)--(6u,4u)--(0,4u)--cycle) shifted (x+62u,y);
draw car;
draw cdr;
draw tag;
label.lft("Symbol" infont "rm-mlmr9", .5[point 0 of car,point 3 of car]);
label.top("char" infont "rm-mlmri9", .5[point 0 of car,point 1 of car] shifted (0,.1mm));
label.bot("63..34" infont "rm-mlmr9",  .5[point 0 of car,point 1 of car]);
label.top("next" infont "rm-mlmri9", .5[point 0 of cdr,point 1 of cdr] shifted (0,.1mm));
label.bot("33..2" infont "rm-mlmr9",  .5[point 0 of cdr,point 1 of cdr]);
label.top("11" infont "rm-mlmtt8", .5[point 0 of tag,point 1 of tag]);
label.bot("1..0" infont "rm-mlmr9",   .5[point 0 of tag,point 1 of tag]);

#+end_src

*** Free List Figure
#+name: Free List Figure
#+begin_src metapost :noweb yes
\medskip\medskip
\mplibcode
beginfig(1);
<<metapost-graph-init>>
<<make_figure(mem=free-list-memory, positions=free-list-positions)>>
endfig;
\endmplibcode
\medskip\medskip
#+end_src

#+name: free-list-memory
| addr | type | head | tail | val |
|    1 | cons |    0 |    2 |     |
|    2 | cons |    0 |    3 |     |
|    3 | cons |    0 |    4 |     |
|    4 | cons |    0 |    0 |     |


#+name: free-list-positions
| F | 1 | 2 | 3 | 4  |



*** Validate Cell Implementation

| tag a | tag b | type                  |
|     0 |     0 | 62 bit signed integer |
|     1 |     0 | 7 bytes of UTF-8?     |
|     0 |     1 | cons cell             |
|     1 |     1 | symbol head?          |

The most positive number has a 0 in the most significant position and
1's elsewhere: 01…1112 = 2N−1 − 1. The most negative number has a 1 in
the most significant position and 0's elsewhere: 10…0002 = −2N−1.

#+begin_src python :results output :var cons_examples=cons_examples :var number_examples=number_examples
import bitstring
#print('0'*31 + '1'*31)
#print('0'*62)
#print('1'*62)
#print(bitstring.Bits(bin='0b01111111111111111111111111111111111111111111111111111111111111', length=62).int)
#print(bitstring.Bits(bin='0b10000000000000000000000000000000000000000000000000000000000000', length=62).int)
#print(bitstring.Bits(int=2305843009213693952, length=63).bin)
for head, tail, cell, notes in cons_examples[1:]:
    cell = bitstring.Bits(bin=cell.replace(' ', ''), length=64).hex
    print(f'    assert(mkcons({head}, {tail}) == 0x{cell}); // {notes}')

for vin, vout, cell, notes in number_examples[1:]:
    cell = bitstring.Bits(bin=cell.replace(' ', ''), length=64).hex
    print(f'    assert(mknumber({vin}) == 0x{cell} && "{notes}");')
    print(f'    assert(deref_number_from_cell(mknumber({vin})) == {vout} && "{notes}");')
#+end_src

#+RESULTS:
#+begin_example
    assert(mkcons(0, 0xffff'ffff).val == 0x00000001fffffffd); // Numbers are truncated to 31 bits
    assert(mkcons(0xffff'ffff, 0).val == 0xfffffffe00000001); // Numbers are truncated to 31 bits
    assert(mknumber(0) == 0x0000000000000000 && "Zero");
    assert(deref_number_from_cell(mknumber(0)) == 0 && "Zero");
    assert(mknumber(-1) == 0xfffffffffffffffc && "Negative numbers are represeted properly");
    assert(deref_number_from_cell(mknumber(-1)) == -1 && "Negative numbers are represeted properly");
    assert(mknumber(2305843009213693951) == 0x7ffffffffffffffc && "Most positive number");
    assert(deref_number_from_cell(mknumber(2305843009213693951)) == 2305843009213693951 && "Most positive number");
    assert(mknumber(-2305843009213693952) == 0x8000000000000000 && "Most negative number");
    assert(deref_number_from_cell(mknumber(-2305843009213693952)) == -2305843009213693952 && "Most negative number");
    assert(mknumber(2305843009213693952) == 0x8000000000000000 && "Most positive number + 1 gets truncated");
    assert(deref_number_from_cell(mknumber(2305843009213693952)) == -2305843009213693952 && "Most positive number + 1 gets truncated");
#+end_example

#+name: cons_examples
| Head        | Tail        | Cell                                                                | Notes                            |
| 0           | 0xffff'ffff | 0000000000000000000000000000000 1111111111111111111111111111111 01  | Numbers are truncated to 31 bits |
| 0xffff'ffff | 0           | 1111111111111111111111111111111 0000000000000000000000000000000 01  | Numbers are truncated to 31 bits |

#+name: number_examples
|             Value In |            Value Out | Cell                                                              | Notes                                    |
|                    0 |                    0 | 00000000000000000000000000000000000000000000000000000000000000 00 | Zero                                     |
|                   -1 |                   -1 | 11111111111111111111111111111111111111111111111111111111111111 00 | Negative numbers are represeted properly |
|  2305843009213693951 |  2305843009213693951 | 01111111111111111111111111111111111111111111111111111111111111 00 | Most positive number                     |
| -2305843009213693952 | -2305843009213693952 | 10000000000000000000000000000000000000000000000000000000000000 00 | Most negative number                     |
|  2305843009213693952 | -2305843009213693952 | 10000000000000000000000000000000000000000000000000000000000000 00 | Most positive number + 1 gets truncated  |

#+name: Validate Cell Implementation
#+begin_src c
// TODO: make this invisible to cweave and add table of same info
void validate_cell_implementation(void) @+ {
    assert(iscons(mkcons(0, 0)));
    assert(isnumber(mknumber(0)));
    assert(issymbol(mksymbol('A', 0)));
    ///////////////////
    assert(mkcons(0, 0xffff'ffff).val == 0x00000001fffffffd); // Numbers are truncated to 31 bits
    assert(mkcons(0xffff'ffff, 0).val == 0xfffffffe00000001); // Numbers are truncated to 31 bits
    assert(mknumber(0).val == 0x0000000000000000 && "Zero");
    assert(deref_number_from_cell(mknumber(0)) == 0 && "Zero");
    assert(mknumber(-1).val == 0xfffffffffffffffc && "Negative numbers are represeted properly");
    assert(deref_number_from_cell(mknumber(-1)) == -1 && "Negative numbers are represeted properly");
    assert(mknumber(2305843009213693951).val == 0x7ffffffffffffffc && "Most positive number");
    assert(deref_number_from_cell(mknumber(2305843009213693951)) == 2305843009213693951 && "Most positive number");
    assert(mknumber(-2305843009213693952).val == 0x8000000000000000 && "Most negative number");
    assert(deref_number_from_cell(mknumber(-2305843009213693952)) == -2305843009213693952 && "Most negative number");
    assert(mknumber(2305843009213693952).val == 0x8000000000000000 && "Most positive number + 1 gets truncated");
    assert(deref_number_from_cell(mknumber(2305843009213693952)) == -2305843009213693952 && "Most positive number + 1 gets truncated");
}
#+end_src

*** Dump Cells Implementation

#+begin_src c
void dump_sexp_r(index start) @+ {
    index i = start;
    if (i && i < 1010) {
        cell c = mem[i];
        if (cons(c)) {
            printf("%u [label=\"<car> %llu | <cdr> %llu\"];\n", i, head(c), tail(c));
            if (head(c)) {
                printf("%d:car->%llu;\n", i, head(c));
                dump_sexp_r(head(c));
            }
            if (tail(c)) {
                printf("%d:cdr->%llu;\n", i, tail(c));
                dump_sexp_r(tail(c));
            }
        }
        else if (isnumber(c)) {
            printf("%u [label=\"%lld\" shape=\"doublecircle\"];\n", i, number(c));
        }
    }
}

void dump_sexp(index start) {
    printf("digraph structs { node [shape=record];\n");
    dump_sexp_r(start);
    printf("}\n");
};
#+end_src


*** Cell Initialization

#+name: Cell Initialization
#+begin_src c
for(int i = 0; i < limit; i++) @+ {
    mem[i] = mkcons(0, (i+1)%limit); // Modulo math! Last cell gets a 0 as the tail
}
mem[NIL] = (cell){0};
mem[F] = mksymbol('F', NIL);
mem[T] = mksymbol('T', NIL);
f = 1;

#+end_src

*** LD Instruction

#+name: LD Instruction
#+begin_src c
index locate(index pair) @+ {
    // This all assumes head and tail return an index
    int64_t frame    = getnumber2(mem[head(mem[pair])]);
    int64_t position = getnumber2(mem[tail(mem[pair])]); // Is ordinal a better name?
    index w = e;                              // 0. Start at the top of the environment
    while (frame-- > 0) w = tail(mem[w]);     // 1. walk to the correct frame
    w = head(mem[w]);                         // 2. step onto the frame's list
    while (position-- > 0) w = tail(mem[w]); // 3. walk to the correct position
    return head(mem[w]);                      // 4. step onto the position's value
}

void ld(void) @+ {
    // GUIDO: This is the same as push, should we just call it that?
    s = addcons(locate(popc()), s);
}
#+end_src

*** LDC Instruction

#+name: LDC Instruction
#+begin_src c
void ldc(void) @+ {
    s = addcons(popc(), s);
}
#+end_src

*** LDF Instruction

#+name: LDF Instruction
#+begin_src c
void ldf(void) @+ {
    s = addcons(addcons(popc(), e), s);
}
#+end_src

*** AP Instruction

#+name: AP Instruction
#+begin_src c
void ap(void) @+ {
    index w = popc();
    index v = popc();
    d = addcons(s, addcons(e, addcons(c, d)));
    c = head(mem[w]);
    e = addcons(v, tail(mem[w]));
}
#+end_src

*** RTN Instruction

#+name: RTN Instruction
#+begin_src c
void rtn(void) @+ {
    index w = popd();
    s = addcons(head(mem[s]), w);
    e = popd();
    c = popd();
}
#+end_src

*** DUM Instruction

#+name: DUM Instruction
#+begin_src c
#+end_src

*** RAP Instruction

#+name: RAP Instruction
#+begin_src c
#+end_src

*** SEL Instruction

#+name: SEL Instruction
#+begin_src c
#+end_src

*** JOIN Instruction

#+name: JOIN Instruction
#+begin_src c
#+end_src

*** CAR Instruction

#+name: CAR Instruction
#+begin_src c
void car(void) @+ {
    index w = pops();
    s = addcons(head(mem[w]), s);
}
#+end_src

*** CDR Instruction

#+name: CDR Instruction
#+begin_src c
void cdr(void) @+ {
    index w = pops();
    s = addcons(tail(mem[w]), s);
}
#+end_src

*** ATOM Instruction

#+name: ATOM Instruction
#+begin_src c
void atom(void) @+ {
    index w = pops();
    bool atom = !iscons(mem[w]);
    s = addcons(atom ? T : F, s);
}
#+end_src

*** CONS Instruction

#+name: CONS Instruction
#+begin_src c
void cons(void) @+ {
    index w = addcons(pops(), pops());
    s = addcons(w, s);
}
#+end_src

*** EQ Instruction

#+name: EQ Instruction
#+begin_src c
void eq(void) @+ {
    index x = pops();
    index y = pops();
    bool b = x == y || getnumber2(mem[x]) == getnumber2(mem[y]);
    s = addcons(b ? T : F, s);
}
#+end_src

*** ADD Instruction

#+name: ADD Instruction
#+begin_src c
void add(void) @+ {
    int64_t x = getnumber2(mem[pops()]);
    int64_t y = getnumber2(mem[pops()]);
    s = addcons(addcell(mknumber(x + y)), s);
}
#+end_src

*** SUB Instruction

#+name: SUB Instruction
#+begin_src c
void sub(void) @+ {
    int64_t x = getnumber2(mem[pops()]);
    int64_t y = getnumber2(mem[pops()]);
    s = addcons(addcell(mknumber(y - x)), s);
}
#+end_src

*** MUL Instruction

#+name: MUL Instruction
#+begin_src c
void mul(void) @+ {
    int64_t x = getnumber2(mem[pops()]);
    int64_t y = getnumber2(mem[pops()]);
    s = addcons(addcell(mknumber(x * y)), s);
}
#+end_src

*** DIV Instruction

#+name: DIV Instruction
#+begin_src c
void div(void) @+ {
    int64_t x = getnumber2(mem[pops()]);
    int64_t y = getnumber2(mem[pops()]);
    s = addcons(addcell(mknumber(y / x)), s);
}
#+end_src

*** REM Instruction

#+name: REM Instruction
#+begin_src c
void rem(void) @+ {
    int64_t x = getnumber2(mem[pops()]);
    int64_t y = getnumber2(mem[pops()]);
    s = addcons(addcell(mknumber(y % x)), s);
}
#+end_src

*** LEQ Instruction

#+name: LEQ Instruction
#+begin_src c
void leq(void) @+ {
    index x = pops();
    index y = pops();
    bool b = getnumber2(mem[y]) <= getnumber2(mem[x]);
    s = addcons(b ? T : F, s);
}
#+end_src

*** STOP Instruction

#+name: STOP Instruction
#+begin_src c
#+end_src

** Convert before-after register table

#+name: make_tex_secd_table
#+begin_src python :results output :var table=[]
print(r"""\medskip\medskip{\eightrm\halign{#\hfil\quad&#\hfil\quad&#\hfil\quad&#\hfil\cr
Stack & Environment & Control & Dump\cr
\noalign{\smallskip\hrule}\cr
""")

for row in table:
    print(' & '.join(row), r'\cr')

print(r'}}\medskip\medskip')
#+end_src

** Make side-by-side before and after figures TODO WORK IN PROGRESS

#+name: make_before_after_figs
#+begin_src python :results output :var num=999 :var op=""
print(f"""\medskip\medskip
\mplibcode
beginfig({num});
<<metapost-graph-init>>
<<make_figure(mem={op}-memory, positions={op}-before)>>
picture pic;
pic := currentpicture;
currentpicture := nullpicture;
draw pic shifted ((-dx*8),0);
<<make_figure(mem={op}-memory, positions={op}-after)>>
endfig;
\endmplibcode
\medskip\medskip""")
#+end_src

** Convert test data to graphs and tests

*** Metapost Graph Init
#+name: metapost-graph-init
#+begin_src metapost
u = 1mm; w = 6u; h = 4u; dx = 10u; dy = -8u; defaultfont := "rm-mlmtt8";
path cell[];
def register(expr name, i, j, to) =
  pair a;
  a = (dx*i + w,dy*j) shifted (0,-h/2);
  label.lft(name, a);
  drawarrow a..(point 0 of cell[to] shifted (0,-h/2));
enddef;
def cons(expr k, i, j) =
  cell[k] := ((0,0)--(w,0)--(w,-h)--(0,-h)--(0,0)--(w/2,0)--(w/2,-h)) shifted (dx*i,dy*j);
  draw cell[k];
  label.ulft(decimal k infont "cmr8" scaled .7, point 0 of cell[k] shifted (1u,0));
enddef;
def atom(expr k, i, j, v) =
  cell[k] := ((0,0)--(w,0)--(w,-h)--(0,-h)--(0,0)--(w/2,0)) shifted (dx*i,dy*j);
  draw cell[k];
  label.bot(v, point 5 of cell[k]);
  label.ulft(decimal k infont "cmr8" scaled .7, point 0 of cell[k] shifted (1u,0));
enddef;
def downarrow(expr from, to) =
  drawarrow (point 0 of cell[from] + (.25w,-.5h))..(point 0 of cell[to] + (.25w,0));
enddef;
def rightarrow(expr from, to) =
  drawarrow (point 1 of cell[from] + (-.25w,-.5h))..(point 0 of cell[to] + (0,-.5h));
enddef;
def nil(expr k) =
  draw (point 6 of cell[k]..(point 1 of cell[k]));
enddef;
#+end_src

*** Cells Helper

#+name: cells_helper
#+begin_src python
from dataclasses import make_dataclass, dataclass
from pprint import pprint as pp

@dataclass
class Cell:
    addr: str
    type: str
    head: str
    tail: str
    val: str

    def cons(self):
        return self.type == 'cons'

    def symbol(self):
        return self.type == 'symbol'

cells = {}
for m in mem[1:]:
    c = Cell(*m)
    cells[c.addr] = c
#+end_src

*** Make Figure
#+name: make_figure
#+begin_src python :results output :var mem=[] :var positions=[] :noweb yes
<<cells_helper>>

def enumerate_table(table):
    for j, line in enumerate(table):
        for i, c in enumerate(line):
            if c != '':
                yield (c, i, j)

def draw_figure(data):
    arrows = []
    for c, i, j in enumerate_table(data):
        if c in {'S', 'E', 'C', 'D', 'F'}:
            right = next(d for d in data[j][i+1:] if d)
            arrows.append(f'register("{c}", {i}, {j}, {right});')
            continue
        diy = False
        if '*' in str(c):
            c = int(c.strip('*'))
            diy = True
        c = cells[c]
        if c.cons():
            print(f'cons({c.addr}, {i}, {j});')
            if c.head:
                arrows.append(f'downarrow({c.addr}, {c.head});')
            if c.tail == 0:
                arrows.append(f'nil({c.addr});')
            elif c.tail and not diy:
                arrows.append(f'rightarrow({c.addr}, {c.tail});')
        else:
            print(f'atom({c.addr}, {i}, {j}, "{c.val}");')
    print('\n'.join(arrows))


draw_figure(positions)
#+end_src

*** Make Tests
#+name: make_tests
#+begin_src python :results output :var mem=[] :var positions=[] :noweb yes
<<cells_helper>>

OPCODE = {'LD': 1, 'LDC': 2, 'LDF': 3, 'AP': 4, 'RTN': 5, 'DUM': 6, 'RAP': 7,
          'SEL': 8, 'JOIN': 9, 'CAR':10, 'CDR':11, 'ATOM':12, 'CONS':13, 'EQ':14,
          'ADD':15, 'SUB':16, 'MUL':17, 'DIV':18, 'REM':19, 'LEQ':20, 'STOP':21}

for c in cells.values():
    if c.cons():
        v = f'mkcons({c.head}, {c.tail})'
    elif c.symbol():
        # TODO: do the rest of the characters
        v = f'mksymbol({ord(c.val[0])}, {c.tail})'
    else:
        if isinstance(c.val, int):
            v = f'mknumber({c.val})'
        else:
            if c.val in OPCODE:
                v = f"mknumber({OPCODE[c.val]})"
            else:
                v = f"mknumber('{c.val}')"
    print(f'mem[{c.addr}] = {v};')
#+end_src

** References

- [[http://eschulte.github.io/org-scraps/][Org Scraps]]
- [[http://eschulte.github.io/org-scraps/scraps/2011-08-05-tangle-before-evaluating-a-code-block.html][Tangle Before Evaluate]]  
- [[https://emacs.stackexchange.com/questions/51145/what-is-the-equivalent-of-the-org-babel-call-in-emacs-lisp][What is the equivalent of the org-babel CALL in emacs-lisp?]]
- [[https://github.com/dfeich/org-babel-examples/blob/master/tables/tables.org][Advanced Table Syntax]]



